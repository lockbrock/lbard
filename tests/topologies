#!/bin/bash

# Tests for Serval LBARD
#
# Copyright 2016 Serval Project, Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


source "${0%/*}/../serval-dna/testframework.sh"
source "${0%/*}/../topology_testdefs.sh"

lbard_console() {
   local C="$instance_name"
   executeOk --core-backtrace --timeout=600 --executable="lbard"  --stdout-file="${C}_LBARDOUT" --stderr-file="${C}_LBARDERR" $*
   tfw_cat --stdout --stderr
}

fork_lbard_console() {
   local C="$instance_name"
   fork %lbard$C lbard_console "$*"
}

setup_bundles() {
   # Configure four servald daemons without any interfaces connecting them, and
   # start them running.
   setup_servald
   assert_no_servald_processes
   foreach_instance +A +B +C +D create_single_identity
   echo "1: $1"
   echo "2: $2"
   echo "3: $3"
   eval v="$4"
   echo "4: ${v}"
   # Create files in each servald instance if requested
   if [ "x$2" != "x" ]; then
      # 2: number of common files
       common_files=$2
       n=0
       while [ $n -lt $files_per_instance ]
       do
         ++n
	      set_instance +A
         create_file file-common-${n} 10000
	      echo -e "service=File\nsender=$SIDA\nrecipient=$SIDB" >file$n.manifest
	      executeOk_servald rhizome add file $SIDA file-common-${n} file${n}.manifest
	      extract_manifest_id BID file${n}.manifest
	      extract_manifest_version VERSION file${n}.manifest
	      executeOk_servald rhizome export bundle $BID file${n}e.manifest file${n}e
         for i in B C D; do
            set_instance +B
            executeOk_servald rhizome import bundle file1e file1e.manifest	       
         done
      done
   fi
   if [ "x$3" != "x" ]; then
   # 3: number of files per instance
      files_per_instance=$3       
      for i in A B C D
      do
         set_instance +$i
	      local sidvar="SID$instance_name"
         n=0
	      while [ $n -lt $files_per_instance ] 
         do
            n++
            create_file file-$i-$n 10000
            tfw_quietly executeOk_servald rhizome add file "${!sidvar}" file-$i-$n file-$i-$n.manifest	   
	      done
      done
   fi
   eval param="$4"
   if [ "x$params" != "x" ]; then
   # 4: lbard flags
       lbardflags="$4"
   else
       lbardflags=""
   fi
}

start_instances() {   
   # First: radio types, string; ie "rfd900,rfd900,rfd900,rfd900"
   #eval radioTypes=
   # TODO: Add option to not specify radio type
   if [ "x$1" != "x0" ]; then
      fakeradios=$1
   else
      fakeradios=rfd900,rfd900,rfd900,rfd900
   fi

   foreach_instance +A +B +C +D start_servald_server
   get_servald_restful_http_server_port PORTA +A
   get_servald_restful_http_server_port PORTB +B
   get_servald_restful_http_server_port PORTC +C
   get_servald_restful_http_server_port PORTD +D
   # Start the fake radio daemon.
   echo "fakeradio: $fakeradios"
   #echo "1: ${{1}}"
   echo "params: $lbardparams" 

   fork %fakeradio fakecsmaradio "$fakeradios" ttys.txt "$lbardparams"
   wait_until --timeout=15 eval [ '$(cat ttys.txt | wc -l)' -ge 4 ]
   tty1=$(sed -n 1p ttys.txt)
   tty2=$(sed -n 2p ttys.txt)
   tty3=$(sed -n 3p ttys.txt)
   tty4=$(sed -n 4p ttys.txt)
   
   # Start four lbard daemons.
   set_instance +A
   fork_lbard_console "$addr_localhost:$PORTA" lbard:lbard "$SIDA" "$IDA" "$tty1" announce pull ${lbardflags}
   set_instance +B
   fork_lbard_console "$addr_localhost:$PORTB" lbard:lbard "$SIDB" "$IDB" "$tty2" pull ${lbardflags}
   set_instance +C
   fork_lbard_console "$addr_localhost:$PORTC" lbard:lbard "$SIDC" "$IDC" "$tty3" pull ${lbardflags}
   set_instance +D
   fork_lbard_console "$addr_localhost:$PORTD" lbard:lbard "$SIDD" "$IDD" "$tty4" pull ${lbardflags}
}

setup() {
   setup_bundles $*
   start_instances $*
}


setup_common() { # For Wifi/Rhizome 
   setup_servald
   assert_no_servald_processes
   foreach_instance +A +B create_single_identity
   set_instance +B
}

configure_servald_server() {
   # Do not configure any network interfaces.
   # Maybe this has to do with why it wasn't working
   # Not turning on rhizome, so not using it?
   executeOk_servald config \
      set rhizome.http.enable 1 \
      set api.restful.users.lbard.password lbard
}

teardown() {
   stop_all_servald_servers
   kill_all_servald_processes
   assert_no_servald_processes
   report_all_servald_servers
}


doc_FileTransfer="RHIZOME - Wi-fi: New bundle and update transfer to one node"
setup_FileTransfer() {
   setup_common
   set_instance +A
   rhizome_add_file file1 250000
   start_servald_instances +A +B
   foreach_instance +A assert_peers_are_instances +B
   foreach_instance +B assert_peers_are_instances +A
}
test_FileTransfer() {
   receive_and_update_bundle
} 



doc_OneOne="FAKE RADIO - RFD900 - A single very small bundle transfers to a single peer"
setup_OneOne() {
   # TODO: Not actually doing over fake radio right now. Not sure why
   lbardparams="allow between 0,1; deny all;"
   setup 0 0 0 "\${lbardparams}"
   # Insert a file to server A
   set_instance +A
   rhizome_add_file file1 50
}
test_OneOne() {
   # Test that the bundle arrives at server B
   all_bundles_received() {
      bundle_received_by $BID:$VERSION +B 
   }
   wait_until all_bundles_received
}

doc_One="FAKE RADIO - RFD900 - A single very small bundle transfers to 3 peers"
setup_One() {
   lbardparams="allow between 0,3; allow between 3,2; allow between 2,1; deny all;"
   #radios="rfd900,rfd900,rfd900,rfd900"
   setup 0 0 0 "\${lbardparams}"
   # Insert a file to server A
   set_instance +A
   rhizome_add_file file1 50
}
test_One() {
   # Test that the bundle arrives at servers B, C and D
   all_bundles_received() {
      bundle_received_by $BID:$VERSION +B &&
         bundle_received_by $BID:$VERSION +C &&
         bundle_received_by $BID:$VERSION +D
   }
   wait_until all_bundles_received
}
runTests "$@"
